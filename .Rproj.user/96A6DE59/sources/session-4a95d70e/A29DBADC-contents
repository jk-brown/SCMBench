---
title: "Temperature Projection Visualizations"
author: "Joe Brown"
date: "2025-03-07"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Goal

# Set-up

```{r}
source("set-up/source_all.R")
```

# Load data

For this analysis we want to make sure we have to model results in the global environment:

1) model_result that represents the long form selection of model results that identify those projections that align with IPCC assessed ranges. This can be produced by running Rmd `02_searching_for_IPCC_aligned_ensemble`. One this script is run, we only really need to keep the `gsat_data_normalized` object.

2) A model re-run that uses the IPCC_params to produce a result. This can be loaded from the `output/model_results` directory -- file name = `IPCC_params_run.RDS`. Once loaded we will need to adjust it to match the data we want to plot (normalized gsat).

Load model result for the IPCC param re-run:
```{r}
# load result 
model_result_rerun <- readRDS("output/model_results/IPCC_params_run.RDS")

# checking for NAs - there should be none
na_check <- sapply(model_result_rerun, function(df) anyNA(df))

# View
print(na_check)

```
# Managing model results

We want the two model results to represent the same output. Therefore we will manage the re-run model result to include only the gsat variable and will normalize to the same reference period as the initial model result. 

## Extract GSAT Data for "IPCC" result

Extract only the `global_tas` variable (Global Surface Air Temperature) from the model results. This is the key variable for for evaluating the ensemble warming range. 

```{r}
# Extract global_tas from each scenario 
IPCC_gsat_data <- lapply(model_result_rerun, function(df) {  
  
  subset_data = subset(df, variable == "global_tas")
  
  return(subset_data)
})

```

## Filtering gsat_data_normalized for runs the align with IPCC

What we want here is to have a filtered data set from the full normalized gsat data that should only include the run numbers that are in the IPCC aligned results. This makes sure that we are comparing what should theoretically be the same data.

*Need to figure out the best way to have this in here in a sustainable way...as this currently stands this is confusing and not super helpful. Maybe find a way to describe this in an issue to add to github.*

Add GSAT results from init result:

```{r}
init_gsat_data <- readRDS("output/model_results/init_gsat_data_normalized.RDS")

```

Filter `init_gsat_data` to only include the IPCC aligned run numbers (saved in `output/parameters`):

```{r}
## COME BACK TO THIS IT IS NOT QUITE RIGHT ##

# Load IPCC-aligned run numbers
ipcc_aligned_run_numbers <- readRDS("output/parameters/ipcc_aligned_run_numbers.rds")

# Sort them to keep things clean
ipcc_aligned_run_numbers <- sort(ipcc_aligned_run_numbers)

# Remove the bad runs
bad_runs <- c(2250, 2966, 264, 277, 536, 1232, 1321, 1349, 2725, 2820)

ipcc_aligned_run_numbers <- ipcc_aligned_run_numbers[!ipcc_aligned_run_numbers %in% bad_runs]

# Check what you have
print(ipcc_aligned_run_numbers)

# Getting GSAT results that are aligned with IPCC
ipcc_aligned_init_gsat_data <- lapply(init_gsat_data, function(df) {
  
  df %>% filter(run_number %in% ipcc_aligned_run_numbers)
  
})
```

## Normalize GSAT to the IPCC reference period (1995-2014)

Normalize the GSAT time series to the 1995-2014 reference period, consistent with IPCC AR6 convention. 

*Note*: The `normalize_to_reference()` function is provided in the project's `utils` folder: `set-up/utils.R`.

```{r}
# Normalize GSAT data to the 1995–2014 reference period
IPCC_gsat_data_normalized <- lapply(IPCC_gsat_data, function(df) {
  
  normalized <- normalize_to_reference(df, 
                                       reference_start = 1995, 
                                       reference_end = 2014)
  
  return(normalized)
}) 

```

Okay we should now be able to remove the `model_result_rerun` object to help save memory. This is optional and may be situational so I am just performing this in the console.

*NOTE: There is clearly a difference in the two model results, which is concerning and something I will want to figure out. But for now I just want to get some of this code out of the way.*

## Create data frames for plotting

To plot this data we are going to want some data frames. These data frames should include:

1) A df of GSAT normalized data that includes all the model runs from the init result -- `gsat_data_normalized_df`.
2) A df of GSAT normalized data that includes only the IPCC aligned params from param search -- `filtered_gsat_data_normalized_df`.
3) a df the same as number 2 but that comes from the re-run result using the IPCC params -- `IPCC_gsat_data_normalized_df`.

```{r}
# 1
init_gsat_normalized_df <- do.call(rbind, init_gsat_data)

# 2
ipcc_aligned_init_gsat_df <- do.call(rbind, ipcc_aligned_init_gsat_data)

# 3
IPCC_gsat_data_normalized_df <- do.call(rbind, IPCC_gsat_data_normalized)

# we can also try listing this so its all in one place
gsat_results <- list("full_gsat" = init_gsat_normalized_df, 
                     "IPCC_fitered_gsat" = ipcc_aligned_init_gsat_df, 
                     "IPCC_params_gsat" = IPCC_gsat_data_normalized_df)

```

Now I just want to filter this a bit to include the years we want to plot. To be consistent I only want to plot starting from 1995 so anything before then can be dropped.

```{r}
gsat_data_from_95 <- lapply(gsat_results, function(df) {
  
  subset_result <- subset(df, year > 2000 & year < 2100)
  
  return(subset_result)
  
})
```

# Visualizations 

There are a number of visualizations that will be helpful here. This section covers a few:

1) Overlaying the GSAT results. Here we want to show the init result after selection of the ensemble most closely aligned with IPCC results, then we want to show the ensemble run using IPCC aligned params. There won't be a perfect overlap due to NAs in the re-run using IPCC params -- which I think is a `parallel` issue. Ten total ensemble members were removed from the re-run using IPCC params. But the two results should align with the exception of those 10 ensemble members.

```{r}
ggplot() +
  geom_line(data = gsat_data_from_95$IPCC_params_gsat, 
            aes(x = year, y = value, group = run_number, color = "IPCC parameters")) +
  geom_line(data = gsat_data_from_95$IPCC_fitered_gsat, 
            aes(x = year, y = value, group = run_number, color = "Filtered init result"),
            alpha = 0.3) +
  scale_color_manual(values= c("IPCC parameters" = "dodgerblue", 
                               "Filtered init result" = "red")) +
  labs(color = "Data source") +
  facet_wrap(~scenario, scales = "free_y") +
  theme_light()

```

*Okay obviously these are not overlaying as expected. Which means there is something going on in terms of these two analyses not aligning. There could be several reasons. One thing I can check is whether the ensembles causing the mismatch  are those that produced NAs during the re-run.*  

# Compute summary statistics

For each of the full results we want to compute summary statistics that will be used for visualizations. 

## Computing summary stats

```{r, message=FALSE, warning=FALSE}

## compute summary statistics for each gsat result in gsat_results
gsat_summary <- lapply(gsat_data_from_95, function(df) {
  
  summary <- df %>%
  group_by(year, scenario) %>%
  summarise(
    ci_05 = quantile(value, probs = 0.05),
    ci_10 = quantile(value, probs = 0.10),
    ci_15 = quantile(value, probs = 0.15), 
    ci_20 = quantile(value, probs = 0.25),
    ci_25 = quantile(value, probs = 0.25),
    ci_30 = quantile(value, probs = 0.30), 
    ci_35 = quantile(value, probs = 0.35), 
    ci_40 = quantile(value, probs = 0.40), 
    ci_45 = quantile(value, probs = 0.45),
    ci_50 = quantile(value, probs = 0.50),
    ci_55 = quantile(value, probs = 0.55),
    ci_60 = quantile(value, probs = 0.60),
    ci_65 = quantile(value, probs = 0.65),
    ci_70 = quantile(value, probs = 0.70),
    ci_75 = quantile(value, probs = 0.75),
    ci_80 = quantile(value, probs = 0.80),
    ci_85 = quantile(value, probs = 0.85),
    ci_90 = quantile(value, probs = 0.90),
    ci_95 = quantile(value, probs = 0.95),
    .groups = "drop")
  
  return(summary)
  
})

names(gsat_summary) <- names(gsat_data_from_95)

```

```{r}
# Step 3: Plot
ggplot() +
  # Layered ribbons, widest first so they don't cover each other
  geom_ribbon(data = gsat_summary$IPCC_params_gsat, aes(x = year, ymin = ci_05, ymax = ci_95), fill = "red", alpha = 0.1) +
  geom_ribbon(data = gsat_summary$IPCC_params_gsat, aes(x = year, ymin = ci_10, ymax = ci_90), fill = "red", alpha = 0.15) +
  geom_ribbon(data = gsat_summary$IPCC_params_gsat, aes(x = year, ymin = ci_15, ymax = ci_85), fill = "red", alpha = 0.2) +
  geom_ribbon(data = gsat_summary$IPCC_params_gsat, aes(x = year, ymin = ci_20, ymax = ci_80), fill = "red", alpha = 0.25) +
  geom_ribbon(data = gsat_summary$IPCC_params_gsat, aes(x = year, ymin = ci_25, ymax = ci_75), fill = "red", alpha = 0.3) +
  geom_ribbon(data = gsat_summary$IPCC_params_gsat, aes(x = year, ymin = ci_30, ymax = ci_70), fill = "red", alpha = 0.35) +
  geom_ribbon(data = gsat_summary$IPCC_params_gsat, aes(x = year, ymin = ci_35, ymax = ci_65), fill = "red", alpha = 0.4) +
  geom_ribbon(data = gsat_summary$IPCC_params_gsat, aes(x = year, ymin = ci_40, ymax = ci_60), fill = "red", alpha = 0.45) +
  
  # Median line (q50)
  geom_line(data = gsat_summary$IPCC_params_gsat, aes(x = year, y = ci_50), color = "red", size = 1.2) +
  theme_light() +
  facet_wrap(~scenario, scales = "free_y")
```

Can I extract the parameters that align closest to each quantile?
```{r}
# Define RMSE function
rmse <- function(x, y) {
  sqrt(mean((x - y)^2, na.rm = TRUE))
}

# Subset to SSP2-4.5
ensemble_data_ssp245 <- IPCC_gsat_data_normalized$`SSP2-4.5`
quantile_targets_ssp245 <- subset(gsat_summary$IPCC_params_gsat, scenario == "SSP2-4.5")

# List of quantiles you want to match
quantiles_to_match <- paste0("ci_", sprintf("%02d", seq(5, 95, by = 5)))

# Initialize final matching table
final_matching_table <- data.frame(
  quantile = character(),
  run_number = integer(),
  rmse = numeric()
)

# Track used run_numbers
used_runs <- c()

# Loop through each quantile
for (q in quantiles_to_match) {
  
  # Join ensemble and target quantile
  joined <- ensemble_data_ssp245 %>%
    left_join(
      quantile_targets_ssp245 %>% select(year, target_value = all_of(q)),
      by = "year"
    )
  
  # Calculate RMSE for each run_number
  rmse_by_run <- joined %>%
    group_by(run_number) %>%
    summarize(rmse = rmse(value, target_value), .groups = "drop") %>%
    arrange(rmse)
  
  # Exclude already used run_numbers
  rmse_by_run <- rmse_by_run %>%
    filter(!run_number %in% used_runs)
  
  # Pick the best available run
  best_run <- rmse_by_run %>%
    slice(1)
  
  # Save
  final_matching_table <- rbind(final_matching_table, data.frame(
    quantile = q,
    run_number = best_run$run_number,
    rmse = best_run$rmse
  ))
  
  # Update used runs
  used_runs <- c(used_runs, best_run$run_number)
}

# Done
print(final_matching_table)

```

```{r}
# Step 1: Extract matched runs and limit to 2000-2100
matched_runs <- ensemble_data_ssp245 %>%
  filter(run_number %in% final_matching_table$run_number,
         year >= 2000, year <= 2100)

# Step 2: Build quantile ribbons (and limit to 2000-2100)
plot_quantiles <- quantile_targets_ssp245 %>%
  select(year, 
         q05 = ci_05, q10 = ci_10, q15 = ci_15, q20 = ci_20, q25 = ci_25, 
         q30 = ci_30, q35 = ci_35, q40 = ci_40, q45 = ci_45, q50 = ci_50, 
         q55 = ci_55, q60 = ci_60, q65 = ci_65, q70 = ci_70, q75 = ci_75, 
         q80 = ci_80, q85 = ci_85, q90 = ci_90, q95 = ci_95) %>%
  filter(year >= 2000, year <= 2100)

# Step 3: Plot
ggplot() +
  geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q05, ymax = q95), fill = "red", alpha = 0.1) +
  geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q10, ymax = q90), fill = "red", alpha = 0.15) +
  geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q15, ymax = q85), fill = "red", alpha = 0.2) +
  geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q20, ymax = q80), fill = "red", alpha = 0.25) +
  geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q25, ymax = q75), fill = "red", alpha = 0.3) +
  geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q30, ymax = q70), fill = "red", alpha = 0.35) +
  geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q35, ymax = q65), fill = "red", alpha = 0.4) +
  geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q40, ymax = q60), fill = "red", alpha = 0.45) +
  
  geom_line(data = plot_quantiles, aes(x = year, y = q50), color = "red", linewidth = 1.2) +
  geom_line(data = matched_runs, aes(x = year, y = value, group = run_number), color = "dodgerblue", linewidth = 0.3) +
  
  theme_light() +
  labs(
    x = "Year",
    y = "GSAT anomaly (°C relative to 1995–2014)",
    title = "Matched Hector Ensemble Members vs Matilda Quantile Ribbons (2000–2100)"
  )

```

Now I need to know if I can run Matilda with these parameters and get the same result:
```{r}
# Load params
ipcc_params <- read.csv("output/parameters/IPCC_params.csv")
# reset run_numbers 
ipcc_params$run_number <- 1:nrow(ipcc_params)

# filter out parameter sets we know did not result in NAs after re-running the model
bad_runs <- c(2250, 2966, 264, 277, 536, 1232, 1321, 1349, 2725, 2820) # from previously identified NAs in re-run
ipcc_params <- ipcc_params %>%
  filter(!run_number %in% bad_runs)

# are all the run_numbers in final_matching_table located in ipcc_params?
all(final_matching_table$run_number %in% ipcc_params)

# Filter for only the matched run_numbers
matched_params <- ipcc_params %>%
  filter(run_number %in% final_matching_table$run_number)

# Step 4: View or save
print(matched_params)


```

## Now can I re-run Matilda with this result?.
```{r}
ini <- system.file("input/hector_ssp245.ini", package = "hector")

core <- newcore(inifile = ini)

reset(core)

check_matched_params <- matched_params %>% 
  select(-run_number)

check_result <- iterate_model(
  core,
  check_matched_params,
  save_years = 1990:2100,
  save_vars = c("global_tas", "gmst", "CO2_concentration", "ocean_uptake")
)
```

```{r}
# filter out the data we want to plot
check_result_gsat <- check_result %>% 
  filter(variable == "global_tas")

check_result_norm <- normalize_to_reference(check_result_gsat, 
                                       reference_start = 1995, 
                                       reference_end = 2014)

check_result_plot <- check_result_norm %>% 
  filter(year >=2000 & year <= 2100)
```

Plot to see if we are getting what we expect:
```{r}
# Step 2: Build quantile ribbons (and limit to 2000-2100)
plot_quantiles <- quantile_targets_ssp245 %>%
  select(year, 
         q05 = ci_05, q10 = ci_10, q15 = ci_15, q20 = ci_20, q25 = ci_25, 
         q30 = ci_30, q35 = ci_35, q40 = ci_40, q45 = ci_45, q50 = ci_50, 
         q55 = ci_55, q60 = ci_60, q65 = ci_65, q70 = ci_70, q75 = ci_75, 
         q80 = ci_80, q85 = ci_85, q90 = ci_90, q95 = ci_95) %>%
  filter(year >= 2000, year <= 2100)

# Step 3: Plot
ggplot() +
  geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q05, ymax = q95), fill = "red", alpha = 0.1) +
  geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q10, ymax = q90), fill = "red", alpha = 0.15) +
  geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q15, ymax = q85), fill = "red", alpha = 0.2) +
  geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q20, ymax = q80), fill = "red", alpha = 0.25) +
  geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q25, ymax = q75), fill = "red", alpha = 0.3) +
  geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q30, ymax = q70), fill = "red", alpha = 0.35) +
  geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q35, ymax = q65), fill = "red", alpha = 0.4) +
  geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q40, ymax = q60), fill = "red", alpha = 0.45) +
  
  geom_line(data = plot_quantiles, aes(x = year, y = q50), color = "red", linewidth = 1.2) +
  geom_line(data = check_result_plot, aes(x = year, y = value, group = run_number), color = "dodgerblue", linewidth = 0.3) +
  geom_line(data = matched_runs, aes(x = year, y = value, group = run_number), color = "green", linewidth = 0.3) +
  
  theme_light() +
  labs(
    x = "Year",
    y = "GSAT anomaly (°C relative to 1995–2014)",
    title = "Matched Hector Ensemble Members vs Matilda Quantile Ribbons (2000–2100)"
  )

```
Why is this so fucked...
```{r}
# Take a single matched parameter row
test_param <- matched_params[1, , drop = FALSE]
test_param <- test_param %>% 
  select(-run_number)

# Run once
core1 <- newcore(ini)
result1 <- iterate_model(core1, test_param, save_years = 1850:2100)

# Run again
core2 <- newcore(ini)
result2 <- iterate_model(core2, test_param, save_years = 1850:2100)

# Compare
identical(result1$value, result2$value)  # This should return TRUE
```

## Maybe I just need to re-run serially with the IPCC params, then find those quantiles again, then find the ensmeble memebers close, again and then find the params that match again, then try to re-run with those params again?

Re-running serially?
```{r}
ipcc_params <- read.csv("output/parameters/IPCC_params.csv")
# rest run_numbers for params
ipcc_params$run_number <- 1:nrow(ipcc_params)
# take out run_number column to prevent error
params_input <- ipcc_params %>% 
  select(-run_number)

# load ini
ini <- system.file("input/hector_ssp245.ini", package = "hector")

#initialize core
reset(core)
core <- newcore(inifile = ini)

debugging_result <- iterate_model(core, params = params_input, save_years = 1850:2100, save_vars = c(GMST(), GLOBAL_TAS()))

anyNA(debugging_result)
```
```{r}
# Find which run_numbers have at least one NA
runs_with_na <- debugging_result %>%
  group_by(run_number) %>%
  summarize(has_na = any(is.na(value)), .groups = "drop") %>%
  filter(has_na) %>%
  pull(run_number)

# View the run_numbers
print(runs_with_na)
```
filter out to include gsat and then normalize
```{r}
debugging_gsat <- debugging_result %>% 
  filter(variable == "global_tas")

debugging_gsat_normalized <- normalize_to_reference(debugging_gsat, 1995, 2014)

```

Constructing a metric for GSAT calcualtion:
```{r}
warming_metric <- new_metric(GLOBAL_TAS(), years = 2081:2100, op = median)

```

Calculating warming metrics from the model ensemble:
```{r}
# calculating median GSAT for 2081-2100 period
debugging_gsat_median <- metric_calc(debugging_gsat_normalized, metric = warming_metric)

```

Okay so this shows that the results are not exactly the same but it might be close enough to find ensemble members that are close to the quantiles of the ensemble that we aligned closely with IPCC.

And this will hopefully be more reproducible so I can find a parameter set that aligns with the quantiles that are at least close to IPCC.

```{r}
# Define RMSE function
rmse <- function(x, y) {
  sqrt(mean((x - y)^2, na.rm = TRUE))
}

# No need to filter by scenario
ensemble_data <- debugging_gsat_normalized

# Your quantile targets (still subset to SSP2-4.5 from gsat_summary)
quantile_targets <- subset(gsat_summary$IPCC_params_gsat, scenario == "SSP2-4.5")

# List of quantiles to match
quantiles_to_match <- paste0("ci_", sprintf("%02d", seq(5, 95, by = 5)))

# Initialize final matching table
final_matching_table <- data.frame(
  quantile = character(),
  run_number = integer(),
  rmse = numeric()
)

# Track used run_numbers
used_runs <- c()

# Loop through quantiles
for (q in quantiles_to_match) {
  
  # Join ensemble with target quantile
  joined <- ensemble_data %>%
    left_join(
      quantile_targets %>% select(year, target_value = all_of(q)),
      by = "year"
    )
  
  # Compute RMSE per run
  rmse_by_run <- joined %>%
    group_by(run_number) %>%
    summarize(rmse = rmse(value, target_value), .groups = "drop") %>%
    arrange(rmse)
  
  # Exclude already matched runs
  rmse_by_run <- rmse_by_run %>%
    filter(!run_number %in% used_runs)
  
  # Pick best available match
  best_run <- rmse_by_run %>%
    slice(1)
  
  # Save match
  final_matching_table <- rbind(final_matching_table, data.frame(
    quantile = q,
    run_number = best_run$run_number,
    rmse = best_run$rmse
  ))
  
  # Update used run_numbers
  used_runs <- c(used_runs, best_run$run_number)
}

# View matching result
print(final_matching_table)
```


```{r}
# Step 1: Extract matched runs and limit to 2000-2100
debugging_matched_runs <- debugging_gsat_normalized %>%
  filter(run_number %in% final_matching_table$run_number,
         year >= 2000,
         year <= 2100)

# Step 2: Build quantile ribbons (and limit to 2000-2100)
plot_quantiles <- quantile_targets_ssp245 %>%
  select(year, 
         q05 = ci_05, q10 = ci_10, q15 = ci_15, q20 = ci_20, q25 = ci_25, 
         q30 = ci_30, q35 = ci_35, q40 = ci_40, q45 = ci_45, q50 = ci_50, 
         q55 = ci_55, q60 = ci_60, q65 = ci_65, q70 = ci_70, q75 = ci_75, 
         q80 = ci_80, q85 = ci_85, q90 = ci_90, q95 = ci_95) %>%
  filter(year >= 2000, year <= 2100)

# Step 3: Plot
ggplot() +
  geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q05, ymax = q95), fill = "red", alpha = 0.1) +
  geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q10, ymax = q90), fill = "red", alpha = 0.15) +
  geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q15, ymax = q85), fill = "red", alpha = 0.2) +
  geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q20, ymax = q80), fill = "red", alpha = 0.25) +
  geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q25, ymax = q75), fill = "red", alpha = 0.3) +
  geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q30, ymax = q70), fill = "red", alpha = 0.35) +
  geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q35, ymax = q65), fill = "red", alpha = 0.4) +
  geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q40, ymax = q60), fill = "red", alpha = 0.45) +
  
  geom_line(data = plot_quantiles, aes(x = year, y = q50), color = "red", linewidth = 1.2) +
  geom_line(data = debugging_matched_runs, aes(x = year, y = value, group = run_number), color = "dodgerblue", linewidth = 0.3) +
  
  theme_light() +
  labs(
    x = "Year",
    y = "GSAT anomaly (°C relative to 1995–2014)",
    title = "Matched Hector Ensemble Members vs Matilda Quantile Ribbons (2000–2100)"
  )

```
```{r}
quantile_params <- ipcc_params %>% 
  filter(run_number %in% final_matching_table$run_number)

print(quantile_params)
```

Re-run hector to see if this will finally work:
```{r}
#
params_input2 <- quantile_params %>% 
  select(-run_number)

# load ini
ini <- system.file("input/hector_ssp245.ini", package = "hector")

#initialize core
reset(core)
core <- newcore(inifile = ini)

debugging_result2 <- iterate_model(core, params = params_input2, save_years = 1850:2100, save_vars = c(GMST(), GLOBAL_TAS()))
```

```{r}
# gsat results
debugging_gsat2 <- debugging_result2 %>% 
  filter(variable == "global_tas")

debugging_gsat_normalized2 <- normalize_to_reference(debugging_gsat2, 1995, 2014)

# gmst results
debugging_gmst2 <- debugging_result2 %>% 
  filter(variable == "gmst")

debugging_gmst_normalized2 <- normalize_to_reference(debugging_gmst2, 1995, 2014)

# Step 2: Build quantile ribbons (and limit to 2000-2100)
plot_quantiles <- quantile_targets_ssp245 %>%
  select(year, 
         q05 = ci_05, q10 = ci_10, q15 = ci_15, q20 = ci_20, q25 = ci_25, 
         q30 = ci_30, q35 = ci_35, q40 = ci_40, q45 = ci_45, q50 = ci_50, 
         q55 = ci_55, q60 = ci_60, q65 = ci_65, q70 = ci_70, q75 = ci_75, 
         q80 = ci_80, q85 = ci_85, q90 = ci_90, q95 = ci_95) %>%
  filter(year >= 2000, year <= 2100)

# Step 3: Plot
ggplot() +
  # geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q05, ymax = q95), fill = "red", alpha = 0.1) +
  # geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q10, ymax = q90), fill = "red", alpha = 0.15) +
  # geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q15, ymax = q85), fill = "red", alpha = 0.2) +
  # geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q20, ymax = q80), fill = "red", alpha = 0.25) +
  # geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q25, ymax = q75), fill = "red", alpha = 0.3) +
  # geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q30, ymax = q70), fill = "red", alpha = 0.35) +
  # geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q35, ymax = q65), fill = "red", alpha = 0.4) +
  # geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q40, ymax = q60), fill = "red", alpha = 0.45) +
  # 
  # geom_line(data = plot_quantiles, aes(x = year, y = q50), color = "red", linewidth = 1.2) +
  geom_line(data = subset(debugging_gsat_normalized2, 
                          year >= 1995 & year <= 2100), aes(x = year, y = value, group = run_number), color = "dodgerblue", linewidth = 0.3) +
  
  theme_light() +
  labs(
    x = "Year",
    y = "GSAT anomaly (C relative to 1995–2014)",
    title = "Hector ensemble members selected to match Matilda GSAT quantiles (2000–2100)"
  )

```

Constructing a metric for GSAT calculation:
```{r}
gsat_metric <- new_metric(GLOBAL_TAS(), years = 2081:2100, op = median)
gmst_metric <- new_metric(GMST(), years= 2081:2100, op = median)

```

Calculating warming metrics from the model ensemble:
```{r}
# calculating median GSAT for 2081-2100 period
debugging_gsat_median <- metric_calc(debugging_gsat_normalized2, metric = gsat_metric)
debugging_gmst_median <- metric_calc(debugging_gmst_normalized2, metric = gmst_metric)

```

Building final parameter table
```{r}
# Ensure final_matching_table is joined *in the order of quantile_params*
final_param_table <- quantile_params %>%
  inner_join(final_matching_table, by = "run_number") %>%
  select(run_number, quantile, rmse, everything())  # optional: move identifying cols up front

# View result
print(final_param_table)
```

```{r}
# Reset run_numbers in final_param_table to match model output order
final_param_table$run_number <- 1:nrow(final_param_table)

# Now safely join the GSAT and GMST metrics
final_param_table <- final_param_table %>%
  left_join(debugging_gsat_median, by = "run_number") %>%
  left_join(debugging_gmst_median, by = "run_number")

final_param_table <- final_param_table %>%
  mutate(quantile_num = as.numeric(gsub("ci_", "", quantile))) %>%  # extract numeric part
  arrange(quantile_num) %>%
  select(-quantile_num) %>%   # optional: remove helper column
  rename("2081-2100 median GSAT" = metric_result.x, 
         "2081-2100 median GMST" = metric_result.y)

print(final_param_table)

```

```{r}
write.csv(final_param_table, "output/parameters/ssp245_gsat_quantile_matched_params.csv", row.names = F)
```


```{r}
setvar(core, NA, BETA(), 0.502, "(unitless)")
setvar(core, NA, Q10_RH(), 1.79, "(unitless)")
setvar(core, NA, NPP_FLUX0(), 49.68, "Pg C/yr")
setvar(core, NA, AERO_SCALE(), 0.96, "(unitless)")
setvar(core, NA, DIFFUSIVITY(), 2.29, "cm2/s")
setvar(core, NA, ECS(), 2.44, "degC")

reset(core)
run(core)

median_vars <- fetchvars(core, 1995:2100)

median_vars_gsat <- median_vars %>% 
  filter(variable == "global_tas")

median_vars_gsat_norm <- normalize_single_series(median_vars_gsat, 1995, 2014)
```

```{r}
ggplot() +
  # geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q05, ymax = q95), fill = "red", alpha = 0.1) +
  # geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q10, ymax = q90), fill = "red", alpha = 0.15) +
  # geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q15, ymax = q85), fill = "red", alpha = 0.2) +
  # geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q20, ymax = q80), fill = "red", alpha = 0.25) +
  # geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q25, ymax = q75), fill = "red", alpha = 0.3) +
  # geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q30, ymax = q70), fill = "red", alpha = 0.35) +
  # geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q35, ymax = q65), fill = "red", alpha = 0.4) +
  # geom_ribbon(data = plot_quantiles, aes(x = year, ymin = q40, ymax = q60), fill = "red", alpha = 0.45) +
  # 
  # geom_line(data = plot_quantiles, aes(x = year, y = q50), color = "red", linewidth = 1.2) +
  geom_line(data = subset(debugging_gsat_normalized2, 
                          year >= 1995 & year <= 2100), aes(x = year, y = value, group = run_number), color = "dodgerblue", linewidth = 0.3) +
  geom_line( data = median_vars_gsat_norm, 
             aes(x = year, y = normalized_value), color = "red", linewidth = 0.3) +
  
  theme_light() +
  labs(
    x = "Year",
    y = "GSAT anomaly (C relative to 1995–2014)",
    title = "Hector ensemble members selected to match Matilda GSAT quantiles (2000–2100)"
  )

```


## Visulizing median (5-95%) GSAT projections

```{r}
ggplot() +
  geom_line(data = gsat_summary$IPCC_fitered_gsat, 
            aes(x = year, y = median, color = "Filtered init result")) +
  geom_ribbon(data = gsat_summary$IPCC_fitered_gsat, 
              aes(x = year, ymin = ci_05, ymax = ci_95, fill = "Filtered init result"), 
              alpha = 0.3) +
  geom_line(data = gsat_summary$IPCC_params_gsat, 
            aes(x = year, y = median, color = "IPCC parameters")) +
  geom_ribbon(data = gsat_summary$IPCC_params_gsat, 
              aes(x = year, ymin = ci_05, ymax = ci_95, fill = "IPCC parameters"),
              alpha = 0.3) +
  scale_color_manual(values = c("Filtered init result" = "red", 
                                "IPCC parameters" = "dodgerblue")) +
  scale_fill_manual(values = c("Filtered init result" = "red",
                               "IPCC parameters" = "dodgerblue")) +
  labs(color = "Data source", fill = NULL) +
  facet_wrap(~scenario, scales = "free_y") +
  theme_light()

```

## Plotting over IPCC Fig. SM4

MOVE TO A PREPPING DATA SCRIPT:
```{r}
lower = read.csv("data/emulator_data/magicc_lower_data_ssp126.csv") %>% 
  rename(year = x, ci_05 = y) %>% 
  mutate(year = round(year, digits = 0))
upper = read.csv("data/emulator_data/magicc_upper_data_ssp126.csv") %>% 
  rename(year = x, ci_95 = y) %>% 
  mutate(year = round(year, digits = 0))
median = read.csv("data/emulator_data/magicc_median_data_ssp126.csv")%>% 
  rename(year = x, median = y) %>% 
  mutate(year = round(year, digits = 0))

magicc <- median %>% 
  full_join(lower, by = "year") %>% 
  full_join(upper, by = "year") %>% 
  arrange(year) %>%
  mutate(
    median = approx(year, median, xout = year, rule = 2)$y, 
    ci_05 = approx(year, ci_05, xout = year, rule = 2)$y,
    ci_95 = approx(year, ci_95, xout = year, rule = 2)$y
  )

fair_lower = read.csv("data/emulator_data/fair_lower_data_ssp126.csv") %>% 
  rename(year = x, fair_ci_05 = y) %>% 
  mutate(year = round(year, digits = 0))
fair_upper = read.csv("data/emulator_data/fair_upper_data_ssp126.csv") %>% 
  rename(year = x, fair_ci_95 = y) %>% 
  mutate(year = round(year, digits = 0))
fair_median = read.csv("data/emulator_data/fair_median_data_ssp126.csv")%>% 
  rename(year = x, median = y) %>% 
  mutate(year = round(year, digits = 0))

fair <- fair_median %>% 
  full_join(fair_lower, by = "year") %>% 
  full_join(fair_upper, by = "year") %>% 
  arrange(year) %>%
  mutate(
    median = approx(year, median, xout = year, rule = 2)$y, 
    ci_05 = approx(year, fair_ci_05, xout = year, rule = 2)$y,
    ci_95 = approx(year, fair_ci_95, xout = year, rule = 2)$y
  )


emulator_plot <- ggplot() +
  geom_line(data = magicc, aes(x = year, y = median, color = "MAGICC")) +
  geom_ribbon(data = magicc, aes(x = year, ymin = ci_05, ymax = ci_95, fill = "MAGICC"), 
              alpha = 0.3) +
  geom_line(data = fair, aes(x = year, y = median, color = "FaIR")) +
  geom_ribbon(data = fair, aes(x = year, ymin = ci_05, ymax = ci_95, fill = "FaIR"), 
              alpha = 0.3) +
  geom_line(data = filter(gsat_summary$IPCC_params_gsat, scenario == "SSP1-2.6"), 
            aes(x = year, y = median, color = "IPCC parameters")) +
  geom_ribbon(data = filter(gsat_summary$IPCC_params_gsat, scenario == "SSP1-2.6"), 
              aes(x = year, ymin = ci_05, ymax = ci_95, fill = "IPCC parameters"),
              alpha = 0.3) +
  scale_color_manual(values = c( "MAGICC" = "orange",
                                 "FaIR" = "red",
                                "IPCC parameters" = "dodgerblue")) +
  scale_fill_manual(values = c("MAGICC" = "orange",
                               "FaIR" = "red",
                               "IPCC parameters" = "dodgerblue")) +
  labs(color = "Emulator") +
  guides(fill = FALSE) +
  theme_light()
emulator_plot

ggsave("figures/emulator_comparison.png", emulator_plot, 
       width = 18,
       units = "in")
```




```{r}
# # initialize metric 
# long_warming_metric <- new_metric(var = 'global_tas', years = 2081:2100, op = median)
# mid_warming_metric <- new_metric(var = 'global_tas', years = 2041:2060, op = median)
# short_warming_metric <- new_metric(var = 'global_tas', years = 2021:2040, op = median)
# 
# metric_list <- list('2081-2100' = long_warming_metric, 
#                     '2041-2060' = mid_warming_metric, 
#                     '2021-2040' = short_warming_metric)
# 
# # compute mid-term warming metrics
# warming_result <- lapply(names(gsat_data_rerun_normalized), function(scenario_name) {
#   
#   # copy gsat data
#   df <- gsat_data_normalized[[scenario_name]]
#   
#   # compute metrics for each term length for current scenario element 
#   metrics_by_term <- lapply(names(metric_list), function(term_length) {
# 
#     # copy metric data
#     metric <- metric_list[[term_length]]
#         
#     # compute metrics
#     result <- metric_calc(df, metric)
#     
#     # add term_length column
#     result$term_length <- term_length
#   
#     return(result)  
#   })  
#   
#   # rbind term_lengths for currrent scenario element
#   metrics_by_scenario <- do.call(rbind, metrics_by_term)
#   
#   # Add column for scenario name
#   metrics_by_scenario$scenario <- scenario_name
#   
#   return(metrics_by_scenario)
# 
# })
# 
# # bind metric result for all scenarios to one df
# metrics_df <- do.call(rbind, warming_result)

```

```{r}
## Wamring median and range

wamring_ranges <- metrics_df %>% 
  group_by(term_length, scenario) %>% 
  summarise(
    lower = quantile(metric_result, probs = c(0.05)), 
    central = quantile(metric_result, probs = c(0.5)), 
    upper = quantile(metric_result, probs = c(0.95)),
  .groups = "drop")

```


